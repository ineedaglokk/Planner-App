# iOS/macOS –ü–ª–∞–Ω–Ω–µ—Ä - –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

## –û–≥–ª–∞–≤–ª–µ–Ω–∏–µ
1. [–û–±–∑–æ—Ä –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã](#–æ–±–∑–æ—Ä-–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã)
2. [–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞](#—Å—Ç—Ä—É–∫—Ç—É—Ä–∞-–ø—Ä–æ–µ–∫—Ç–∞)
3. [–ú–æ–¥–µ–ª–∏ –¥–∞–Ω–Ω—ã—Ö (SwiftData)](#–º–æ–¥–µ–ª–∏-–¥–∞–Ω–Ω—ã—Ö-swiftdata)
4. [–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã](#–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ-–ø–∞—Ç—Ç–µ—Ä–Ω—ã)
5. [–°–µ—Ä–≤–∏—Å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞](#—Å–µ—Ä–≤–∏—Å–Ω–∞—è-–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞)
6. [–ù–∞–≤–∏–≥–∞—Ü–∏—è –∏ UI](#–Ω–∞–≤–∏–≥–∞—Ü–∏—è-–∏-ui)
7. [–î–∏–∑–∞–π–Ω-—Å–∏—Å—Ç–µ–º–∞](#–¥–∏–∑–∞–π–Ω-—Å–∏—Å—Ç–µ–º–∞)
8. [–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è](#–∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏-–∏-—Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è)
9. [Data Flow –∏ State Management](#data-flow-–∏-state-management)
10. [–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å](#–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å-–∏-–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å)

---

## –û–±–∑–æ—Ä –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã

### –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –ø—Ä–∏–Ω—Ü–∏–ø—ã
- **Offline-first**: –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –±–µ–∑ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞
- **Modular Design**: –ù–µ–∑–∞–≤–∏—Å–∏–º—ã–µ feature-–º–æ–¥—É–ª–∏ —Å —á–µ—Ç–∫–∏–º–∏ –≥—Ä–∞–Ω–∏—Ü–∞–º–∏
- **Protocol-Oriented**: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø—Ä–æ—Ç–æ–∫–æ–ª–æ–≤ –¥–ª—è –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–∏
- **Declarative UI**: SwiftUI –¥–ª—è –≤—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
- **Async/Await**: –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥ –∫ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–º—É –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—é
- **Clean Architecture**: –ß–µ—Ç–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ —Å–ª–æ–µ–≤ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏

### –¢–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π —Å—Ç–µ–∫
```
Platform: iOS 17.0+, macOS 14.0+, watchOS 10.0+
Language: Swift 5.9+
UI Framework: SwiftUI 5.0
Data: SwiftData + CloudKit
Architecture: MVVM + Swift Concurrency + Analytics Layer
Navigation: NavigationStack
Charts: Swift Charts + Custom Analytics Components
Widgets: WidgetKit + App Intents
Health: HealthKit + Advanced Correlations        üÜï
Analytics: Statistical Analysis + ML Predictions üÜï
Smart Features: Intelligent Reminders + AI       üÜï
Testing: XCTest + Swift Testing + Performance Tests
CI/CD: Xcode Cloud + GitHub Actions
```

---

## –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞

### –§–∞–π–ª–æ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
```
PlannerApp/
‚îú‚îÄ‚îÄ üìÅ App/                          # Application Entry Point
‚îÇ   ‚îú‚îÄ‚îÄ PlannerApp.swift            # Main App file
‚îÇ   ‚îú‚îÄ‚îÄ ContentView.swift           # Root content view
‚îÇ   ‚îî‚îÄ‚îÄ AppDelegate.swift           # App lifecycle
‚îú‚îÄ‚îÄ üìÅ Core/                         # Core Infrastructure
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ Models/                  # SwiftData Models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ User.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Habit.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HabitEntry.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HealthData.swift                 # üÜï –ú–æ–¥–µ–ª–∏ –¥–ª—è HealthKit –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Task.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Goal.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Transaction.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Budget.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Achievement.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Category.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ModelContainer+Extensions.swift
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ Services/                # Business Logic Services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DataService.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ NotificationService.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HealthKitService.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AdvancedHealthKitService.swift   # üÜï HealthKit –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –∞–Ω–∞–ª–∏—Ç–∏–∫–æ–π
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HabitAnalyticsService.swift      # üÜï –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞ –ø—Ä–∏–≤—ã—á–µ–∫
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SmartFeaturesService.swift       # üÜï –£–º–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GameService.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SyncService.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ServiceContainer.swift
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ Repositories/            # Data Access Layer
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HabitRepository.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TaskRepository.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FinanceRepository.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ UserRepository.swift
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ Utilities/               # Helpers & Extensions
‚îÇ       ‚îú‚îÄ‚îÄ Extensions/
‚îÇ       ‚îú‚îÄ‚îÄ Constants.swift
‚îÇ       ‚îú‚îÄ‚îÄ Formatters.swift
‚îÇ       ‚îî‚îÄ‚îÄ ErrorHandling.swift
‚îú‚îÄ‚îÄ üìÅ Features/                     # Feature Modules
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ Dashboard/               # Overview & Analytics
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ViewModels/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Components/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ Habits/                  # Habit Tracking
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HabitsListView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HabitDetailView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateHabitView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HabitCalendarView.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HabitHeatmapView.swift           # üÜï –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –∫–∞–ª–µ–Ω–¥–∞—Ä—å-heatmap
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AnalyticsTabView.swift           # üÜï –≠–∫—Ä–∞–Ω –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –ø—Ä–∏–≤—ã—á–µ–∫
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ViewModels/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HabitsListViewModel.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HabitDetailViewModel.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateHabitViewModel.swift
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HabitAnalyticsViewModel.swift     # üÜï –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –ø—Ä–∏–≤—ã—á–µ–∫
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HealthIntegrationViewModel.swift  # üÜï HealthKit –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TrendsViewModel.swift             # üÜï –¢—Ä–µ–Ω–¥—ã –∏ –ø—Ä–æ–≥–Ω–æ–∑—ã
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ InsightsViewModel.swift           # üÜï –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ –∏–Ω—Å–∞–π—Ç—ã
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Components/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ HabitCardView.swift
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ StreakView.swift
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ProgressRingView.swift
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ Tasks/                   # Task Management
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ViewModels/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Components/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ Finance/                 # Financial Management
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ViewModels/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Components/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ Goals/                   # Goal Setting
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ViewModels/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Components/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ Gamification/            # Points & Achievements
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ViewModels/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Components/
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ Settings/                # App Settings
‚îÇ       ‚îú‚îÄ‚îÄ Views/
‚îÇ       ‚îú‚îÄ‚îÄ ViewModels/
‚îÇ       ‚îî‚îÄ‚îÄ Components/
‚îú‚îÄ‚îÄ üìÅ Shared/                       # Shared UI Components
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ Components/              # Reusable Components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Buttons/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Cards/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Forms/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Charts/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AdvancedChartComponents.swift  # üÜï –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –≥—Ä–∞—Ñ–∏–∫–∏ –∏ –¥–∏–∞–≥—Ä–∞–º–º—ã
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Progress/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ Themes/                  # Design System
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Colors.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Typography.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Spacing.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Theme.swift
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ Navigation/              # Navigation Helpers
‚îÇ       ‚îú‚îÄ‚îÄ NavigationManager.swift
‚îÇ       ‚îú‚îÄ‚îÄ TabRouter.swift
‚îÇ       ‚îî‚îÄ‚îÄ DeepLinkHandler.swift
‚îú‚îÄ‚îÄ üìÅ Widgets/                      # WidgetKit Extensions
‚îÇ   ‚îú‚îÄ‚îÄ HabitWidget/
‚îÇ   ‚îú‚îÄ‚îÄ TaskWidget/
‚îÇ   ‚îú‚îÄ‚îÄ FinanceWidget/
‚îÇ   ‚îî‚îÄ‚îÄ Shared/
‚îú‚îÄ‚îÄ üìÅ Tests/                        # All Tests
‚îÇ   ‚îú‚îÄ‚îÄ UnitTests/
‚îÇ   ‚îú‚îÄ‚îÄ IntegrationTests/
‚îÇ   ‚îú‚îÄ‚îÄ UITests/
‚îÇ   ‚îî‚îÄ‚îÄ PerformanceTests/
‚îî‚îÄ‚îÄ üìÅ Resources/                    # Assets & Configuration
    ‚îú‚îÄ‚îÄ Assets.xcassets
    ‚îú‚îÄ‚îÄ Localizable.strings
    ‚îú‚îÄ‚îÄ Info.plist
    ‚îî‚îÄ‚îÄ Entitlements.plist
```

---

## –ú–æ–¥–µ–ª–∏ –¥–∞–Ω–Ω—ã—Ö (SwiftData)

### –ë–∞–∑–æ–≤—ã–µ –ø—Ä–æ—Ç–æ–∫–æ–ª—ã
```swift
// –ë–∞–∑–æ–≤—ã–µ –ø—Ä–æ—Ç–æ–∫–æ–ª—ã –¥–ª—è –≤—Å–µ—Ö –º–æ–¥–µ–ª–µ–π
protocol Identifiable {
    var id: UUID { get }
}

protocol Timestampable {
    var createdAt: Date { get }
    var updatedAt: Date { get }
}

protocol CloudKitSyncable: Identifiable {
    var cloudKitRecordID: String? { get set }
    var needsSync: Bool { get set }
    var lastSynced: Date? { get set }
}

protocol Gamifiable {
    var points: Int { get }
    func calculatePoints() -> Int
}

protocol Categorizable {
    var category: Category? { get set }
}
```

### –û—Å–Ω–æ–≤–Ω—ã–µ –º–æ–¥–µ–ª–∏

#### 1. User Model
```swift
@Model
final class User: CloudKitSyncable, Timestampable {
    @Attribute(.unique) var id: UUID
    var name: String
    var email: String?
    var preferences: UserPreferences
    var level: Int
    var totalPoints: Int
    var createdAt: Date
    var updatedAt: Date
    
    // CloudKit Sync
    var cloudKitRecordID: String?
    var needsSync: Bool
    var lastSynced: Date?
    
    // Relationships
    @Relationship(deleteRule: .cascade) var habits: [Habit]
    @Relationship(deleteRule: .cascade) var tasks: [Task]
    @Relationship(deleteRule: .cascade) var goals: [Goal]
    @Relationship(deleteRule: .cascade) var transactions: [Transaction]
    @Relationship(deleteRule: .cascade) var achievements: [Achievement]
}

struct UserPreferences: Codable {
    var theme: ThemeMode
    var notifications: NotificationSettings
    var privacy: PrivacySettings
    var language: String
}
```

#### 2. Habit Model
```swift
@Model
final class Habit: CloudKitSyncable, Timestampable, Gamifiable, Categorizable {
    @Attribute(.unique) var id: UUID
    var name: String
    var description: String?
    var icon: String // SF Symbol name
    var color: String // Hex color
    var frequency: HabitFrequency
    var reminderTime: Date?
    var isActive: Bool
    var createdAt: Date
    var updatedAt: Date
    
    // CloudKit Sync
    var cloudKitRecordID: String?
    var needsSync: Bool
    var lastSynced: Date?
    
    // Relationships
    @Relationship(deleteRule: .cascade) var entries: [HabitEntry]
    var category: Category?
    var user: User?
    
    // Computed Properties
    var currentStreak: Int { /* calculation */ }
    var longestStreak: Int { /* calculation */ }
    var completionRate: Double { /* calculation */ }
    var points: Int { calculatePoints() }
    
    func calculatePoints() -> Int {
        return currentStreak * 10 + entries.count * 5
    }
}

enum HabitFrequency: String, Codable, CaseIterable {
    case daily = "daily"
    case weekly = "weekly"
    case custom = "custom"
}
```

#### 3. Task Model
```swift
@Model
final class Task: CloudKitSyncable, Timestampable, Gamifiable, Categorizable {
    @Attribute(.unique) var id: UUID
    var title: String
    var description: String?
    var priority: TaskPriority
    var status: TaskStatus
    var dueDate: Date?
    var estimatedDuration: TimeInterval?
    var actualDuration: TimeInterval?
    var tags: [String]
    var createdAt: Date
    var updatedAt: Date
    
    // CloudKit Sync
    var cloudKitRecordID: String?
    var needsSync: Bool
    var lastSynced: Date?
    
    // Relationships
    var category: Category?
    var user: User?
    var parentGoal: Goal?
    @Relationship(deleteRule: .cascade) var subtasks: [Task]
    var parentTask: Task?
    
    var points: Int { calculatePoints() }
    
    func calculatePoints() -> Int {
        let basePoints = priority.points
        let timeBonus = dueDate?.timeIntervalSinceNow ?? 0 > 0 ? 5 : 0
        return basePoints + timeBonus
    }
}

enum TaskPriority: String, Codable, CaseIterable {
    case low = "low"
    case medium = "medium"
    case high = "high"
    case urgent = "urgent"
    
    var points: Int {
        switch self {
        case .low: return 5
        case .medium: return 10
        case .high: return 15
        case .urgent: return 20
        }
    }
}

enum TaskStatus: String, Codable, CaseIterable {
    case pending = "pending"
    case inProgress = "in_progress"
    case completed = "completed"
    case cancelled = "cancelled"
}
```

#### 4. Transaction Model
```swift
@Model
final class Transaction: CloudKitSyncable, Timestampable, Categorizable {
    @Attribute(.unique) var id: UUID
    var amount: Decimal
    var type: TransactionType
    var description: String?
    var date: Date
    var account: String?
    var receiptPhoto: String? // File path
    var isRecurring: Bool
    var recurringPattern: RecurringPattern?
    var createdAt: Date
    var updatedAt: Date
    
    // CloudKit Sync
    var cloudKitRecordID: String?
    var needsSync: Bool
    var lastSynced: Date?
    
    // Relationships
    var category: Category?
    var user: User?
    var budget: Budget?
}

enum TransactionType: String, Codable, CaseIterable {
    case income = "income"
    case expense = "expense"
    case transfer = "transfer"
}

struct RecurringPattern: Codable {
    var frequency: RecurringFrequency
    var interval: Int
    var endDate: Date?
}

enum RecurringFrequency: String, Codable, CaseIterable {
    case daily, weekly, monthly, yearly
}
```

#### 5. HealthData Model
```swift
@Model
final class HealthData: CloudKitSyncable, Timestampable {
    @Attribute(.unique) var id: UUID
    var date: Date
    var type: HealthDataType
    var value: Double
    var unit: String
    var source: String? // HealthKit source
    var createdAt: Date
    var updatedAt: Date
    
    // CloudKit Sync
    var cloudKitRecordID: String?
    var needsSync: Bool
    var lastSynced: Date?
    
    // Relationships
    var user: User?
}

enum HealthDataType: String, Codable, CaseIterable {
    case steps = "steps"
    case activeCalories = "active_calories"
    case sleepHours = "sleep_hours"
    case heartRate = "heart_rate"
    case weight = "weight"
    case waterIntake = "water_intake"
    case workoutMinutes = "workout_minutes"
    case mindfulnessMinutes = "mindfulness_minutes"
    case bloodPressure = "blood_pressure"
    case bodyTemperature = "body_temperature"
}

@Model
final class HabitHealthCorrelation: CloudKitSyncable, Timestampable {
    @Attribute(.unique) var id: UUID
    var habitId: UUID
    var healthDataType: HealthDataType
    var correlationCoefficient: Double
    var correlationStrength: CorrelationStrength
    var correlationDirection: CorrelationDirection
    var confidence: Double
    var sampleSize: Int
    var calculatedAt: Date
    var createdAt: Date
    var updatedAt: Date
    
    // CloudKit Sync
    var cloudKitRecordID: String?
    var needsSync: Bool
    var lastSynced: Date?
    
    // Relationships
    var user: User?
}

enum CorrelationStrength: String, Codable, CaseIterable {
    case weak = "weak"           // 0.0 - 0.3
    case moderate = "moderate"   // 0.3 - 0.7
    case strong = "strong"       // 0.7 - 1.0
}

enum CorrelationDirection: String, Codable, CaseIterable {
    case positive = "positive"   // +
    case negative = "negative"   // -
    case none = "none"          // ~0
}
```

### ModelContainer –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
```swift
extension ModelContainer {
    static let shared: ModelContainer = {
        let schema = Schema([
            User.self,
            Habit.self,
            HabitEntry.self,
            HealthData.self,               // üÜï HealthKit –¥–∞–Ω–Ω—ã–µ
            HabitHealthCorrelation.self,   // üÜï –ö–æ—Ä—Ä–µ–ª—è—Ü–∏–∏ –ø—Ä–∏–≤—ã—á–µ–∫ –∏ –∑–¥–æ—Ä–æ–≤—å—è
            Task.self,
            Goal.self,
            Transaction.self,
            Budget.self,
            Achievement.self,
            Category.self
        ])
        
        let configuration = ModelConfiguration(
            schema: schema,
            isStoredInMemoryOnly: false,
            cloudKitDatabase: .private("iCloud.com.yourcompany.planner")
        )
        
        do {
            return try ModelContainer(for: schema, configurations: [configuration])
        } catch {
            fatalError("Failed to create ModelContainer: \(error)")
        }
    }()
}
```

---

## –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã

### MVVM + SwiftUI
```swift
// View Model Protocol
protocol ViewModelProtocol: ObservableObject {
    associatedtype State
    associatedtype Input
    
    var state: State { get }
    func send(_ input: Input)
}

// Example ViewModel Implementation
@Observable
final class HabitsListViewModel: ViewModelProtocol {
    
    // MARK: - State
    struct State {
        var habits: [Habit] = []
        var isLoading: Bool = false
        var error: AppError?
        var searchText: String = ""
        var selectedCategory: Category?
    }
    
    // MARK: - Input
    enum Input {
        case loadHabits
        case searchTextChanged(String)
        case categorySelected(Category?)
        case habitToggled(Habit)
        case deleteHabit(Habit)
    }
    
    // MARK: - Properties
    private(set) var state = State()
    
    // Dependencies
    private let habitRepository: HabitRepositoryProtocol
    private let gameService: GameServiceProtocol
    
    // MARK: - Initialization
    init(
        habitRepository: HabitRepositoryProtocol,
        gameService: GameServiceProtocol
    ) {
        self.habitRepository = habitRepository
        self.gameService = gameService
    }
    
    // MARK: - Input Handling
    func send(_ input: Input) {
        Task { @MainActor in
            switch input {
            case .loadHabits:
                await loadHabits()
            case .searchTextChanged(let text):
                state.searchText = text
                await filterHabits()
            case .categorySelected(let category):
                state.selectedCategory = category
                await filterHabits()
            case .habitToggled(let habit):
                await toggleHabit(habit)
            case .deleteHabit(let habit):
                await deleteHabit(habit)
            }
        }
    }
    
    // MARK: - Private Methods
    private func loadHabits() async {
        state.isLoading = true
        
        do {
            let habits = try await habitRepository.fetchActiveHabits()
            state.habits = habits
            state.error = nil
        } catch {
            state.error = AppError.from(error)
        }
        
        state.isLoading = false
    }
}
```

### Repository Pattern
```swift
// Repository Protocol
protocol HabitRepositoryProtocol {
    func fetchActiveHabits() async throws -> [Habit]
    func fetchHabit(by id: UUID) async throws -> Habit?
    func save(_ habit: Habit) async throws
    func delete(_ habit: Habit) async throws
    func markHabitComplete(_ habit: Habit, date: Date) async throws
}

// Repository Implementation
final class HabitRepository: HabitRepositoryProtocol {
    private let modelContext: ModelContext
    private let syncService: SyncServiceProtocol
    
    init(modelContext: ModelContext, syncService: SyncServiceProtocol) {
        self.modelContext = modelContext
        self.syncService = syncService
    }
    
    func fetchActiveHabits() async throws -> [Habit] {
        let descriptor = FetchDescriptor<Habit>(
            predicate: #Predicate { $0.isActive },
            sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
        )
        
        return try modelContext.fetch(descriptor)
    }
    
    func save(_ habit: Habit) async throws {
        modelContext.insert(habit)
        habit.needsSync = true
        habit.updatedAt = Date()
        
        try modelContext.save()
        
        // Trigger sync
        await syncService.scheduleSync()
    }
}
```

---

## –°–µ—Ä–≤–∏—Å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

### Service Container (Dependency Injection)
```swift
protocol ServiceContainerProtocol {
    var dataService: DataServiceProtocol { get }
    var notificationService: NotificationServiceProtocol { get }
    var healthKitService: HealthKitServiceProtocol { get }
    var advancedHealthKitService: AdvancedHealthKitServiceProtocol { get }  // üÜï
    var habitAnalyticsService: HabitAnalyticsServiceProtocol { get }        // üÜï
    var smartFeaturesService: SmartFeaturesServiceProtocol { get }          // üÜï
    var gameService: GameServiceProtocol { get }
    var syncService: SyncServiceProtocol { get }
}

@Observable
final class ServiceContainer: ServiceContainerProtocol {
    lazy var dataService: DataServiceProtocol = DataService(modelContext: modelContext)
    lazy var notificationService: NotificationServiceProtocol = NotificationService()
    lazy var healthKitService: HealthKitServiceProtocol = HealthKitService()
    
    // üÜï –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ —Å–µ—Ä–≤–∏—Å—ã
    lazy var advancedHealthKitService: AdvancedHealthKitServiceProtocol = 
        AdvancedHealthKitService(modelContext: modelContext)
    lazy var habitAnalyticsService: HabitAnalyticsServiceProtocol = 
        HabitAnalyticsService(modelContext: modelContext)
    lazy var smartFeaturesService: SmartFeaturesServiceProtocol = 
        SmartFeaturesService(
            analyticsService: habitAnalyticsService,
            healthKitService: advancedHealthKitService
        )
    
    lazy var gameService: GameServiceProtocol = GameService(dataService: dataService)
    lazy var syncService: SyncServiceProtocol = SyncService(dataService: dataService)
    
    private let modelContext: ModelContext
    
    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }
}

// Environment Key –¥–ª—è –≤–Ω–µ–¥—Ä–µ–Ω–∏—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
struct ServiceContainerKey: EnvironmentKey {
    static let defaultValue: ServiceContainerProtocol = ServiceContainer(
        modelContext: ModelContainer.shared.mainContext
    )
}

extension EnvironmentValues {
    var services: ServiceContainerProtocol {
        get { self[ServiceContainerKey.self] }
        set { self[ServiceContainerKey.self] = newValue }
    }
}
```

### Core Services

#### 1. DataService
```swift
protocol DataServiceProtocol {
    func fetch<T: PersistentModel>(_ type: T.Type, predicate: Predicate<T>?) async throws -> [T]
    func save<T: PersistentModel>(_ model: T) async throws
    func delete<T: PersistentModel>(_ model: T) async throws
    func batchSave<T: PersistentModel>(_ models: [T]) async throws
}

final class DataService: DataServiceProtocol {
    private let modelContext: ModelContext
    
    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }
    
    func fetch<T: PersistentModel>(_ type: T.Type, predicate: Predicate<T>? = nil) async throws -> [T] {
        let descriptor = FetchDescriptor<T>(predicate: predicate)
        return try modelContext.fetch(descriptor)
    }
    
    func save<T: PersistentModel>(_ model: T) async throws {
        modelContext.insert(model)
        try modelContext.save()
    }
}
```

#### 2. NotificationService
```swift
protocol NotificationServiceProtocol {
    func requestPermission() async -> Bool
    func scheduleHabitReminder(_ habit: Habit) async
    func scheduleTaskDeadline(_ task: Task) async
    func cancelNotifications(for id: String) async
    func handleNotificationResponse(_ response: UNNotificationResponse) async
}

final class NotificationService: NSObject, NotificationServiceProtocol {
    private let center = UNUserNotificationCenter.current()
    
    override init() {
        super.init()
        center.delegate = self
    }
    
    func requestPermission() async -> Bool {
        do {
            let granted = try await center.requestAuthorization(
                options: [.alert, .badge, .sound]
            )
            return granted
        } catch {
            return false
        }
    }
    
    func scheduleHabitReminder(_ habit: Habit) async {
        guard let reminderTime = habit.reminderTime else { return }
        
        let content = UNMutableNotificationContent()
        content.title = "–í—Ä–µ–º—è –¥–ª—è –ø—Ä–∏–≤—ã—á–∫–∏"
        content.body = habit.name
        content.sound = .default
        content.categoryIdentifier = "HABIT_REMINDER"
        
        let calendar = Calendar.current
        let components = calendar.dateComponents([.hour, .minute], from: reminderTime)
        let trigger = UNCalendarNotificationTrigger(dateMatching: components, repeats: true)
        
        let request = UNNotificationRequest(
            identifier: "habit-\(habit.id.uuidString)",
            content: content,
            trigger: trigger
        )
        
        try? await center.add(request)
    }
}

extension NotificationService: UNUserNotificationCenterDelegate {
    func userNotificationCenter(
        _ center: UNUserNotificationCenter,
        willPresent notification: UNNotification,
        withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void
    ) {
        completionHandler([.banner, .sound])
    }
}
```

#### 3. GameService
```swift
protocol GameServiceProtocol {
    func awardPoints(_ points: Int, for action: GameAction) async
    func checkAchievements(for user: User) async
    func calculateLevel(from points: Int) -> Int
    func getAvailableChallenges() async -> [Challenge]
}

final class GameService: GameServiceProtocol {
    private let dataService: DataServiceProtocol
    
    init(dataService: DataServiceProtocol) {
        self.dataService = dataService
    }
    
    func awardPoints(_ points: Int, for action: GameAction) async {
        // Implementation
    }
    
    func checkAchievements(for user: User) async {
        // Check various achievement conditions
        await checkStreakAchievements(for: user)
        await checkTaskCompletionAchievements(for: user)
        await checkFinancialGoalAchievements(for: user)
    }
}

enum GameAction {
    case habitCompleted(Habit)
    case taskCompleted(Task)
    case goalAchieved(Goal)
    case streakMilestone(Int)
}
```

---

## –ù–∞–≤–∏–≥–∞—Ü–∏—è –∏ UI

### Navigation Architecture
```swift
// Main Navigation Structure
struct ContentView: View {
    @State private var tabSelection: Tab = .dashboard
    @Environment(\.services) private var services
    
    var body: some View {
        TabView(selection: $tabSelection) {
            DashboardView()
                .tabItem { Label("–û–±–∑–æ—Ä", systemImage: "chart.line.uptrend.xyaxis") }
                .tag(Tab.dashboard)
            
            HabitsView()
                .tabItem { Label("–ü—Ä–∏–≤—ã—á–∫–∏", systemImage: "repeat.circle") }
                .tag(Tab.habits)
            
            TasksView()
                .tabItem { Label("–ó–∞–¥–∞—á–∏", systemImage: "checkmark.circle") }
                .tag(Tab.tasks)
            
            FinanceView()
                .tabItem { Label("–§–∏–Ω–∞–Ω—Å—ã", systemImage: "dollarsign.circle") }
                .tag(Tab.finance)
            
            SettingsView()
                .tabItem { Label("–ù–∞—Å—Ç—Ä–æ–π–∫–∏", systemImage: "gearshape") }
                .tag(Tab.settings)
        }
        .environment(\.services, services)
    }
}

enum Tab: String, CaseIterable {
    case dashboard, habits, tasks, finance, settings
}
```

### NavigationStack Usage
```swift
struct HabitsView: View {
    @State private var navigationPath = NavigationPath()
    @State private var viewModel = HabitsListViewModel()
    
    var body: some View {
        NavigationStack(path: $navigationPath) {
            HabitsListView(viewModel: viewModel)
                .navigationTitle("–ü—Ä–∏–≤—ã—á–∫–∏")
                .navigationDestination(for: HabitDestination.self) { destination in
                    switch destination {
                    case .detail(let habit):
                        HabitDetailView(habit: habit)
                    case .create:
                        CreateHabitView()
                    case .edit(let habit):
                        EditHabitView(habit: habit)
                    }
                }
        }
    }
}

enum HabitDestination: Hashable {
    case detail(Habit)
    case create
    case edit(Habit)
}
```

---

## –î–∏–∑–∞–π–Ω-—Å–∏—Å—Ç–µ–º–∞

### Theme System
```swift
// Theme Protocol
protocol ThemeProtocol {
    var colors: ColorPalette { get }
    var typography: Typography { get }
    var spacing: Spacing { get }
    var cornerRadii: CornerRadii { get }
}

// Color System
struct ColorPalette {
    // Primary Colors
    let primary: Color
    let primaryLight: Color
    let primaryDark: Color
    
    // Secondary Colors
    let secondary: Color
    let secondaryLight: Color
    let secondaryDark: Color
    
    // Semantic Colors
    let success: Color
    let warning: Color
    let error: Color
    let info: Color
    
    // Neutral Colors
    let background: Color
    let surface: Color
    let onBackground: Color
    let onSurface: Color
    
    // Text Colors
    let textPrimary: Color
    let textSecondary: Color
    let textTertiary: Color
}

// Typography System
struct Typography {
    let largeTitle: Font
    let title1: Font
    let title2: Font
    let title3: Font
    let headline: Font
    let body: Font
    let callout: Font
    let subheadline: Font
    let footnote: Font
    let caption1: Font
    let caption2: Font
}

// Spacing System (8pt grid)
struct Spacing {
    static let xs: CGFloat = 4
    static let sm: CGFloat = 8
    static let md: CGFloat = 16
    static let lg: CGFloat = 24
    static let xl: CGFloat = 32
    static let xxl: CGFloat = 48
}
```

### Reusable Components
```swift
// Primary Button Component
struct PrimaryButton: View {
    let title: String
    let action: () -> Void
    let isLoading: Bool
    let isDisabled: Bool
    
    init(
        _ title: String,
        isLoading: Bool = false,
        isDisabled: Bool = false,
        action: @escaping () -> Void
    ) {
        self.title = title
        self.isLoading = isLoading
        self.isDisabled = isDisabled
        self.action = action
    }
    
    var body: some View {
        Button(action: action) {
            HStack {
                if isLoading {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        .scaleEffect(0.8)
                }
                
                Text(title)
                    .font(.headline)
                    .fontWeight(.semibold)
            }
            .frame(maxWidth: .infinity)
            .frame(height: 50)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(isDisabled ? Color.gray : Theme.colors.primary)
            )
            .foregroundColor(.white)
        }
        .disabled(isDisabled || isLoading)
        .animation(.easeInOut(duration: 0.2), value: isLoading)
    }
}

// Card Component
struct CardView<Content: View>: View {
    let content: Content
    let padding: EdgeInsets
    
    init(
        padding: EdgeInsets = EdgeInsets(
            top: Spacing.md,
            leading: Spacing.md,
            bottom: Spacing.md,
            trailing: Spacing.md
        ),
        @ViewBuilder content: () -> Content
    ) {
        self.padding = padding
        self.content = content()
    }
    
    var body: some View {
        content
            .padding(padding)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(Theme.colors.surface)
                    .shadow(
                        color: Color.black.opacity(0.1),
                        radius: 4,
                        x: 0,
                        y: 2
                    )
            )
    }
}
```

---

## –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è

### WidgetKit Integration
```swift
// Widget Bundle
@main
struct PlannerWidgets: WidgetBundle {
    var body: some Widget {
        HabitProgressWidget()
        TaskSummaryWidget()
        FinanceOverviewWidget()
    }
}

// Habit Progress Widget
struct HabitProgressWidget: Widget {
    let kind: String = "HabitProgressWidget"
    
    var body: some WidgetConfiguration {
        AppIntentConfiguration(
            kind: kind,
            intent: HabitWidgetConfigurationIntent.self,
            provider: HabitTimelineProvider()
        ) { entry in
            HabitProgressWidgetView(entry: entry)
        }
        .configurationDisplayName("–ü—Ä–æ–≥—Ä–µ—Å—Å –ø—Ä–∏–≤—ã—á–µ–∫")
        .description("–û—Ç—Å–ª–µ–∂–∏–≤–∞–π—Ç–µ —Å–≤–æ–∏ –ø—Ä–∏–≤—ã—á–∫–∏ –ø—Ä—è–º–æ —Å –≥–ª–∞–≤–Ω–æ–≥–æ —ç–∫—Ä–∞–Ω–∞")
        .supportedFamilies([.systemSmall, .systemMedium])
    }
}

// Timeline Provider
struct HabitTimelineProvider: AppIntentTimelineProvider {
    func placeholder(in context: Context) -> HabitEntry {
        HabitEntry(date: Date(), habits: sampleHabits)
    }
    
    func snapshot(for configuration: HabitWidgetConfigurationIntent, in context: Context) async -> HabitEntry {
        HabitEntry(date: Date(), habits: await loadHabits())
    }
    
    func timeline(for configuration: HabitWidgetConfigurationIntent, in context: Context) async -> Timeline<HabitEntry> {
        let habits = await loadHabits()
        let entry = HabitEntry(date: Date(), habits: habits)
        
        // Update timeline every hour
        let nextUpdate = Calendar.current.date(byAdding: .hour, value: 1, to: Date()) ?? Date()
        return Timeline(entries: [entry], policy: .after(nextUpdate))
    }
}
```

### App Intents (Siri Integration)
```swift
// Mark Habit Complete Intent
struct MarkHabitCompleteIntent: AppIntent {
    static var title: LocalizedStringResource = "–û—Ç–º–µ—Ç–∏—Ç—å –ø—Ä–∏–≤—ã—á–∫—É –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω–æ–π"
    static var description = IntentDescription("–û—Ç–º–µ—Ç–∏—Ç—å –ø—Ä–∏–≤—ã—á–∫—É –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—É—é –Ω–∞ —Å–µ–≥–æ–¥–Ω—è")
    
    @Parameter(title: "–ü—Ä–∏–≤—ã—á–∫–∞")
    var habit: HabitEntity
    
    func perform() async throws -> some IntentResult {
        let habitRepository = ServiceContainer.shared.habitRepository
        
        do {
            try await habitRepository.markHabitComplete(habit.habit, date: Date())
            
            return .result(dialog: "–ü—Ä–∏–≤—ã—á–∫–∞ \(habit.name) –æ—Ç–º–µ—á–µ–Ω–∞ –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω–∞—è!")
        } catch {
            throw AppError.failedToMarkHabitComplete
        }
    }
}

// Habit Entity for App Intents
struct HabitEntity: AppEntity {
    let id: UUID
    let name: String
    let habit: Habit
    
    static var typeDisplayRepresentation: TypeDisplayRepresentation = "–ü—Ä–∏–≤—ã—á–∫–∞"
    
    var displayRepresentation: DisplayRepresentation {
        DisplayRepresentation(title: "\(name)")
    }
    
    static var defaultQuery = HabitEntityQuery()
}
```

### HealthKit Integration
```swift
protocol HealthKitServiceProtocol {
    func requestAuthorization() async -> Bool
    func syncStepCount() async throws -> Int
    func syncSleepData() async throws -> [SleepSample]
    func syncWorkoutData() async throws -> [WorkoutSample]
}

final class HealthKitService: HealthKitServiceProtocol {
    private let healthStore = HKHealthStore()
    
    func requestAuthorization() async -> Bool {
        guard HKHealthStore.isHealthDataAvailable() else { return false }
        
        let typesToRead: Set<HKObjectType> = [
            HKQuantityType.quantityType(forIdentifier: .stepCount)!,
            HKCategoryType.categoryType(forIdentifier: .sleepAnalysis)!,
            HKObjectType.workoutType()
        ]
        
        do {
            try await healthStore.requestAuthorization(toShare: [], read: typesToRead)
            return true
        } catch {
            return false
        }
    }
    
    func syncStepCount() async throws -> Int {
        let stepType = HKQuantityType.quantityType(forIdentifier: .stepCount)!
        let now = Date()
        let startOfDay = Calendar.current.startOfDay(for: now)
        
        let predicate = HKQuery.predicateForSamples(
            withStart: startOfDay,
            end: now,
            options: .strictStartDate
        )
        
        return try await withCheckedThrowingContinuation { continuation in
            let query = HKStatisticsQuery(
                quantityType: stepType,
                quantitySamplePredicate: predicate,
                options: .cumulativeSum
            ) { _, result, error in
                if let error = error {
                    continuation.resume(throwing: error)
                    return
                }
                
                let stepCount = result?.sumQuantity()?.doubleValue(for: HKUnit.count()) ?? 0
                continuation.resume(returning: Int(stepCount))
            }
            
            healthStore.execute(query)
        }
    }
}
```

### AdvancedHealthKitService - –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è HealthKit –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è

```swift
protocol AdvancedHealthKitServiceProtocol {
    func requestAdvancedPermissions() async -> Bool
    func syncAllHealthData() async throws
    func calculateHabitHealthCorrelations(_ habit: Habit) async throws -> [HabitHealthCorrelation]
    func generateHealthInsights(for user: User) async throws -> [HealthInsight]
    func setupBackgroundDelivery() async throws
}

final class AdvancedHealthKitService: AdvancedHealthKitServiceProtocol {
    private let healthStore = HKHealthStore()
    private let modelContext: ModelContext
    
    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }
    
    func calculateHabitHealthCorrelations(_ habit: Habit) async throws -> [HabitHealthCorrelation] {
        // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø—Ä–∏–≤—ã—á–∫–∏ –∏ –∑–¥–æ—Ä–æ–≤—å—è –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 90 –¥–Ω–µ–π
        let healthData = try await getHealthDataForCorrelation(days: 90)
        let habitData = try await getHabitCompletionData(habit, days: 90)
        
        var correlations: [HabitHealthCorrelation] = []
        
        for (healthType, healthValues) in healthData {
            let correlation = calculatePearsonCorrelation(habitData, healthValues)
            
            if abs(correlation) > 0.1 { // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø–æ—Ä–æ–≥ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏
                let correlationModel = HabitHealthCorrelation(
                    habitId: habit.id,
                    healthDataType: healthType,
                    correlationCoefficient: correlation,
                    correlationStrength: determineStrength(correlation),
                    correlationDirection: determineDirection(correlation),
                    confidence: calculateConfidence(habitData.count),
                    sampleSize: habitData.count
                )
                correlations.append(correlationModel)
            }
        }
        
        return correlations
    }
    
    private func calculatePearsonCorrelation(_ x: [Double], _ y: [Double]) -> Double {
        guard x.count == y.count, x.count > 1 else { return 0.0 }
        
        let n = Double(x.count)
        let sumX = x.reduce(0, +)
        let sumY = y.reduce(0, +)
        let sumXY = zip(x, y).map(*).reduce(0, +)
        let sumXX = x.map { $0 * $0 }.reduce(0, +)
        let sumYY = y.map { $0 * $0 }.reduce(0, +)
        
        let numerator = n * sumXY - sumX * sumY
        let denominator = sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY))
        
        return denominator != 0 ? numerator / denominator : 0.0
    }
}
```

### HabitAnalyticsService - –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞

```swift
protocol HabitAnalyticsServiceProtocol {
    func getHabitTrends(_ habit: Habit, period: AnalyticsPeriod) async throws -> HabitTrends
    func getHabitHeatmapData(_ habit: Habit, year: Int?) async throws -> HabitHeatmapData
    func getWeeklyPatterns(_ habit: Habit) async throws -> WeeklyPatterns
    func getSuccessRateAnalysis(_ habit: Habit) async throws -> SuccessRateAnalysis
    func getHabitCorrelationMatrix(_ habits: [Habit]) async throws -> CorrelationMatrix
}

final class HabitAnalyticsService: HabitAnalyticsServiceProtocol {
    private let modelContext: ModelContext
    
    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }
    
    func getHabitTrends(_ habit: Habit, period: AnalyticsPeriod) async throws -> HabitTrends {
        let calendar = Calendar.current
        let endDate = Date()
        let startDate = calendar.date(byAdding: period.calendarComponent, value: -period.value, to: endDate)!
        
        // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∑–∞ –ø–µ—Ä–∏–æ–¥
        let entries = try await getHabitEntries(habit, from: startDate, to: endDate)
        
        // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –¥–Ω—è–º/–Ω–µ–¥–µ–ª—è–º/–º–µ—Å—è—Ü–∞–º –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø–µ—Ä–∏–æ–¥–∞
        let groupedData = groupEntriesByPeriod(entries, period: period)
        
        // –í—ã—á–∏—Å–ª—è–µ–º —Ç—Ä–µ–Ω–¥
        let trendDirection = calculateTrendDirection(groupedData)
        let trendStrength = calculateTrendStrength(groupedData)
        
        // –ü—Ä–æ–≥–Ω–æ–∑–∏—Ä—É–µ–º —Å–ª–µ–¥—É—é—â–∏–π –ø–µ—Ä–∏–æ–¥
        let prediction = predictNextPeriod(groupedData)
        
        return HabitTrends(
            direction: trendDirection,
            strength: trendStrength,
            prediction: prediction,
            dataPoints: groupedData.map { TrendDataPoint(date: $0.date, value: $0.completionRate) }
        )
    }
    
    func getHabitHeatmapData(_ habit: Habit, year: Int?) async throws -> HabitHeatmapData {
        let targetYear = year ?? Calendar.current.component(.year, from: Date())
        let calendar = Calendar.current
        
        let startDate = calendar.date(from: DateComponents(year: targetYear, month: 1, day: 1))!
        let endDate = calendar.date(from: DateComponents(year: targetYear + 1, month: 1, day: 1))!
        
        let entries = try await getHabitEntries(habit, from: startDate, to: endDate)
        
        // –°–æ–∑–¥–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–Ω—è –≥–æ–¥–∞
        var heatmapData: [HeatmapDataPoint] = []
        var currentDate = startDate
        
        while currentDate < endDate {
            let dayEntries = entries.filter { calendar.isDate($0.date, inSameDayAs: currentDate) }
            let intensity = calculateIntensity(for: dayEntries, habit: habit)
            
            heatmapData.append(HeatmapDataPoint(
                date: currentDate,
                intensity: intensity,
                completed: !dayEntries.isEmpty
            ))
            
            currentDate = calendar.date(byAdding: .day, value: 1, to: currentDate)!
        }
        
        return HabitHeatmapData(
            year: targetYear,
            dataPoints: heatmapData,
            statistics: calculateYearlyStatistics(heatmapData)
        )
    }
}
```

### SmartFeaturesService - –£–º–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏

```swift
protocol SmartFeaturesServiceProtocol {
    func generateIntelligentReminders(for habit: Habit) async throws -> [IntelligentReminder]
    func suggestOptimalTiming(for habit: Habit) async throws -> OptimalTimingSuggestion
    func generateHabitSuggestions(based existingHabits: [Habit]) async throws -> [HabitSuggestion]
    func predictHabitSuccess(for habit: Habit, date: Date) async throws -> SuccessPrediction
    func analyzeUserPatterns(_ user: User) async throws -> UserPatternAnalysis
}

final class SmartFeaturesService: SmartFeaturesServiceProtocol {
    private let analyticsService: HabitAnalyticsServiceProtocol
    private let healthKitService: AdvancedHealthKitServiceProtocol
    
    init(analyticsService: HabitAnalyticsServiceProtocol, 
         healthKitService: AdvancedHealthKitServiceProtocol) {
        self.analyticsService = analyticsService
        self.healthKitService = healthKitService
    }
    
    func generateIntelligentReminders(for habit: Habit) async throws -> [IntelligentReminder] {
        // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ—Å—Ç–∏
        let weeklyPatterns = try await analyticsService.getWeeklyPatterns(habit)
        let successRates = weeklyPatterns.dayOfWeekSuccessRates
        
        var reminders: [IntelligentReminder] = []
        
        // –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –¥–ª—è –¥–Ω–µ–π —Å –Ω–∏–∑–∫–æ–π —É—Å–ø–µ—à–Ω–æ—Å—Ç—å—é
        for (dayOfWeek, successRate) in successRates {
            if successRate < 0.7 { // –ï—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ—Å—Ç—å –º–µ–Ω–µ–µ 70%
                let reminder = IntelligentReminder(
                    type: .adaptive,
                    dayOfWeek: dayOfWeek,
                    suggestedTime: calculateOptimalTime(for: habit, dayOfWeek: dayOfWeek),
                    message: generatePersonalizedMessage(habit, successRate: successRate),
                    priority: calculateReminderPriority(successRate)
                )
                reminders.append(reminder)
            }
        }
        
        // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ–ª—å–Ω—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –ø–æ—Å–ª–µ –ø—Ä–æ–ø—É—Å–∫–æ–≤
        if habit.currentStreak == 0 && habit.lastCompletedDate != nil {
            let daysSinceLastCompletion = Calendar.current.dateComponents([.day], 
                from: habit.lastCompletedDate!, to: Date()).day ?? 0
            
            if daysSinceLastCompletion > 1 {
                let reminder = IntelligentReminder(
                    type: .recovery,
                    dayOfWeek: nil,
                    suggestedTime: Date().addingTimeInterval(3600), // –ß–µ—Ä–µ–∑ —á–∞—Å
                    message: "–ù–µ –∑–∞–±—É–¥—å—Ç–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–µ—Ä–∏—é –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è '\(habit.name)'!",
                    priority: .high
                )
                reminders.append(reminder)
            }
        }
        
        return reminders
    }
    
    func predictHabitSuccess(for habit: Habit, date: Date) async throws -> SuccessPrediction {
        // –°–æ–±–∏—Ä–∞–µ–º —Ñ–∞–∫—Ç–æ—Ä—ã –¥–ª—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
        let weeklyPatterns = try await analyticsService.getWeeklyPatterns(habit)
        let trends = try await analyticsService.getHabitTrends(habit, period: .month)
        
        let dayOfWeek = Calendar.current.component(.weekday, from: date)
        let weekdaySuccessRate = weeklyPatterns.dayOfWeekSuccessRates[dayOfWeek] ?? 0.5
        
        // –í–∑–≤–µ—à–∏–≤–∞–µ–º —Ñ–∞–∫—Ç–æ—Ä—ã
        var predictionScore = 0.0
        predictionScore += weekdaySuccessRate * 0.4  // 40% - —É—Å–ø–µ—à–Ω–æ—Å—Ç—å –≤ –¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏
        predictionScore += max(0, trends.strength) * 0.3  // 30% - –æ–±—â–∏–π —Ç—Ä–µ–Ω–¥
        predictionScore += min(1.0, Double(habit.currentStreak) / 30.0) * 0.2  // 20% - —Ç–µ–∫—É—â–∞—è —Å–µ—Ä–∏—è
        predictionScore += calculateRecentActivityScore(habit) * 0.1  // 10% - –Ω–µ–¥–∞–≤–Ω—è—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
        
        let confidence = calculatePredictionConfidence(
            dataPoints: weeklyPatterns.sampleSize,
            trendStrength: trends.strength
        )
        
        return SuccessPrediction(
            probability: predictionScore,
            confidence: confidence,
            factors: [
                .weekdaySuccess(weekdaySuccessRate),
                .overallTrend(trends.strength),
                .currentStreak(Double(habit.currentStreak)),
                .recentActivity(calculateRecentActivityScore(habit))
            ],
            recommendations: generateSuccessRecommendations(predictionScore)
        )
    }
}
```

### –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ UI –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏

#### HabitHeatmapView - –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –∫–∞–ª–µ–Ω–¥–∞—Ä—å
```swift
struct HabitHeatmapView: View {
    let habit: Habit
    let year: Int
    @State private var selectedDate: Date?
    @State private var hoveredDate: Date?
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å –≥–æ–¥–æ–º
            HStack {
                Text("–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –∑–∞ \(year) –≥–æ–¥")
                    .font(.headline)
                Spacer()
                HStack(spacing: 8) {
                    ForEach(intensityLevels, id: \.self) { level in
                        Rectangle()
                            .fill(colorForIntensity(level))
                            .frame(width: 12, height: 12)
                    }
                    Text("–ë–æ–ª—å—à–µ")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
            }
            
            // –ö–∞–ª–µ–Ω–¥–∞—Ä—å-heatmap
            LazyVGrid(columns: Array(repeating: GridItem(.flexible(), spacing: 2), count: 53), spacing: 2) {
                ForEach(heatmapData.dataPoints, id: \.date) { dataPoint in
                    Rectangle()
                        .fill(colorForIntensity(dataPoint.intensity))
                        .frame(width: 12, height: 12)
                        .onHover { isHovering in
                            hoveredDate = isHovering ? dataPoint.date : nil
                        }
                        .onTapGesture {
                            selectedDate = dataPoint.date
                        }
                }
            }
            
            // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            HStack {
                StatView(title: "–í—Å–µ–≥–æ –¥–Ω–µ–π", value: "\(heatmapData.statistics.totalDays)")
                StatView(title: "–í—ã–ø–æ–ª–Ω–µ–Ω–æ", value: "\(heatmapData.statistics.completedDays)")
                StatView(title: "–£—Å–ø–µ—à–Ω–æ—Å—Ç—å", value: "\(Int(heatmapData.statistics.successRate * 100))%")
            }
        }
        .padding()
        .background(Theme.colors.surface)
        .cornerRadius(12)
    }
}
```

#### AnalyticsTabView - –ì–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω –∞–Ω–∞–ª–∏—Ç–∏–∫–∏
```swift
struct AnalyticsTabView: View {
    @State private var selectedTab: AnalyticsTab = .overview
    @Environment(\.services) private var services
    @StateObject private var viewModel: HabitAnalyticsViewModel
    
    enum AnalyticsTab: String, CaseIterable {
        case overview = "–û–±–∑–æ—Ä"
        case trends = "–¢—Ä–µ–Ω–¥—ã"
        case heatmap = "–ö–∞–ª–µ–Ω–¥–∞—Ä—å"
        case patterns = "–ü–∞—Ç—Ç–µ—Ä–Ω—ã"
        case insights = "–ò–Ω—Å–∞–π—Ç—ã"
        case performance = "–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å"
    }
    
    var body: some View {
        VStack(spacing: 0) {
            // –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å –≤—ã–±–æ—Ä–æ–º –ø—Ä–∏–≤—ã—á–∫–∏
            HStack {
                Text("–ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –ø—Ä–∏–≤—ã—á–µ–∫")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                
                Spacer()
                
                HabitPicker(selectedHabit: $viewModel.selectedHabit)
            }
            .padding()
            
            // –¢–∞–±—ã
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 0) {
                    ForEach(AnalyticsTab.allCases, id: \.self) { tab in
                        Button(tab.rawValue) {
                            selectedTab = tab
                        }
                        .foregroundStyle(selectedTab == tab ? .primary : .secondary)
                        .fontWeight(selectedTab == tab ? .semibold : .regular)
                        .padding(.horizontal, 16)
                        .padding(.vertical, 8)
                        .background(
                            selectedTab == tab ?
                            Theme.colors.accent.opacity(0.1) : Color.clear
                        )
                        .cornerRadius(8)
                    }
                }
                .padding(.horizontal)
            }
            
            // –°–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤–∫–ª–∞–¥–æ–∫
            TabView(selection: $selectedTab) {
                OverviewTab(viewModel: viewModel)
                    .tag(AnalyticsTab.overview)
                
                TrendsTab(viewModel: viewModel)
                    .tag(AnalyticsTab.trends)
                
                HeatmapTab(viewModel: viewModel)
                    .tag(AnalyticsTab.heatmap)
                
                PatternsTab(viewModel: viewModel)
                    .tag(AnalyticsTab.patterns)
                
                InsightsTab(viewModel: viewModel)
                    .tag(AnalyticsTab.insights)
                
                PerformanceTab(viewModel: viewModel)
                    .tag(AnalyticsTab.performance)
            }
            .tabViewStyle(.page(indexDisplayMode: .never))
        }
    }
}
```

#### AdvancedChartComponents - –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –≥—Ä–∞—Ñ–∏–∫–∏
```swift
// –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è —Ç–µ–ø–ª–æ–≤–∞—è –∫–∞—Ä—Ç–∞
struct InteractiveHeatmap: View {
    let data: [HeatmapDataPoint]
    let onDateSelected: (Date) -> Void
    
    @State private var selectedDataPoint: HeatmapDataPoint?
    @State private var hoveredDataPoint: HeatmapDataPoint?
    
    var body: some View {
        Chart(data, id: \.date) { dataPoint in
            RectangleMark(
                x: .value("Week", weekOfYear(dataPoint.date)),
                y: .value("Day", dayOfWeek(dataPoint.date))
            )
            .foregroundStyle(colorForIntensity(dataPoint.intensity))
            .opacity(hoveredDataPoint?.date == dataPoint.date ? 0.8 : 1.0)
        }
        .chartAngleSelection(value: .constant(nil))
        .chartBackground { chartProxy in
            GeometryReader { geometry in
                Rectangle()
                    .fill(.clear)
                    .contentShape(Rectangle())
                    .gesture(
                        DragGesture(minimumDistance: 0)
                            .onChanged { value in
                                // –õ–æ–≥–∏–∫–∞ hover
                            }
                    )
            }
        }
    }
}

// –ú–Ω–æ–≥–æ—Å–µ—Ä–∏–π–Ω—ã–π –ª–∏–Ω–µ–π–Ω—ã–π –≥—Ä–∞—Ñ–∏–∫ —Å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è–º–∏
struct TrendLineChart: View {
    let data: [TrendDataSeries]
    let predictions: [PredictionDataPoint]?
    
    var body: some View {
        Chart {
            // –ò—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
            ForEach(data, id: \.name) { series in
                ForEach(series.dataPoints, id: \.date) { point in
                    LineMark(
                        x: .value("Date", point.date),
                        y: .value("Value", point.value)
                    )
                    .foregroundStyle(by: .value("Series", series.name))
                    .interpolationMethod(.catmullRom)
                }
            }
            
            // –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
            if let predictions = predictions {
                ForEach(predictions, id: \.date) { prediction in
                    LineMark(
                        x: .value("Date", prediction.date),
                        y: .value("Prediction", prediction.predictedValue)
                    )
                    .foregroundStyle(.orange)
                    .lineStyle(StrokeStyle(lineWidth: 2, dash: [5, 5]))
                    
                    // –î–æ–≤–µ—Ä–∏—Ç–µ–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
                    AreaMark(
                        x: .value("Date", prediction.date),
                        yStart: .value("Lower", prediction.confidenceInterval.lower),
                        yEnd: .value("Upper", prediction.confidenceInterval.upper)
                    )
                    .foregroundStyle(.orange.opacity(0.2))
                }
            }
        }
        .chartLegend(position: .top)
        .chartXAxis {
            AxisMarks(values: .stride(by: .day, count: 7)) { value in
                AxisGridLine()
                AxisValueLabel(format: .dateTime.weekday(.abbreviated))
            }
        }
        .animation(.easeInOut(duration: 0.8), value: data)
    }
}

// –ì—Ä–∞—Ñ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–π –º–µ–∂–¥—É –ø—Ä–∏–≤—ã—á–∫–∞–º–∏
struct CorrelationGraphView: View {
    let correlations: CorrelationMatrix
    @State private var selectedNode: HabitNode?
    
    var body: some View {
        Canvas { context, size in
            // –†–∏—Å—É–µ–º —É–∑–ª—ã (–ø—Ä–∏–≤—ã—á–∫–∏)
            for node in correlations.nodes {
                let position = nodePosition(for: node, in: size)
                
                // –£–∑–µ–ª
                context.fill(
                    Circle().path(in: CGRect(
                        origin: CGPoint(x: position.x - 20, y: position.y - 20),
                        size: CGSize(width: 40, height: 40)
                    )),
                    with: .color(colorForHabit(node.habit))
                )
                
                // –ü–æ–¥–ø–∏—Å—å
                context.draw(
                    Text(node.habit.name)
                        .font(.caption)
                        .foregroundColor(.primary),
                    at: CGPoint(x: position.x, y: position.y + 30)
                )
            }
            
            // –†–∏—Å—É–µ–º —Å–≤—è–∑–∏ (–∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏)
            for edge in correlations.edges {
                let fromPosition = nodePosition(for: edge.fromNode, in: size)
                let toPosition = nodePosition(for: edge.toNode, in: size)
                
                let lineWidth = abs(edge.correlation) * 5 // –¢–æ–ª—â–∏–Ω–∞ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Å–∏–ª—ã –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏
                let color = edge.correlation > 0 ? Color.green : Color.red
                
                context.stroke(
                    Path { path in
                        path.move(to: fromPosition)
                        path.addLine(to: toPosition)
                    },
                    with: .color(color.opacity(abs(edge.correlation))),
                    lineWidth: lineWidth
                )
            }
        }
        .gesture(
            DragGesture()
                .onChanged { value in
                    // –õ–æ–≥–∏–∫–∞ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è —É–∑–ª–æ–≤
                }
        )
    }
}
```

---

## Data Flow –∏ State Management

### Reactive Data Flow
```swift
// Observable State Management
@Observable
final class AppState {
    var user: User?
    var isAuthenticated: Bool = false
    var networkStatus: NetworkStatus = .unknown
    var syncStatus: SyncStatus = .idle
    
    // Feature States
    var habitsState = HabitsState()
    var tasksState = TasksState()
    var financeState = FinanceState()
}

@Observable
final class HabitsState {
    var habits: [Habit] = []
    var selectedHabit: Habit?
    var isLoading: Bool = false
    var error: AppError?
    var filters: HabitFilters = HabitFilters()
}

// State Updates —á–µ—Ä–µ–∑ Actions
enum AppAction {
    case userAuthenticated(User)
    case userLoggedOut
    case networkStatusChanged(NetworkStatus)
    case syncStatusChanged(SyncStatus)
    
    // Habit Actions
    case habitsLoaded([Habit])
    case habitCreated(Habit)
    case habitUpdated(Habit)
    case habitDeleted(UUID)
}

// Action Handler
final class AppActionHandler {
    func handle(_ action: AppAction, state: inout AppState) {
        switch action {
        case .userAuthenticated(let user):
            state.user = user
            state.isAuthenticated = true
            
        case .userLoggedOut:
            state.user = nil
            state.isAuthenticated = false
            state.habitsState = HabitsState()
            state.tasksState = TasksState()
            state.financeState = FinanceState()
            
        case .habitsLoaded(let habits):
            state.habitsState.habits = habits
            state.habitsState.isLoading = false
            
        case .habitCreated(let habit):
            state.habitsState.habits.append(habit)
            
        // ... other actions
        }
    }
}
```

### Error Handling
```swift
enum AppError: Error, LocalizedError {
    case networkUnavailable
    case dataCorrupted
    case syncFailed(String)
    case authenticationFailed
    case permissionDenied
    case unknown(Error)
    
    var errorDescription: String? {
        switch self {
        case .networkUnavailable:
            return "–ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É"
        case .dataCorrupted:
            return "–î–∞–Ω–Ω—ã–µ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω—ã"
        case .syncFailed(let reason):
            return "–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: \(reason)"
        case .authenticationFailed:
            return "–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"
        case .permissionDenied:
            return "–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω"
        case .unknown(let error):
            return error.localizedDescription
        }
    }
    
    static func from(_ error: Error) -> AppError {
        if let appError = error as? AppError {
            return appError
        }
        return .unknown(error)
    }
}

// Error Handler Service
protocol ErrorHandlerProtocol {
    func handle(_ error: AppError)
    func showErrorAlert(_ error: AppError)
    func logError(_ error: AppError)
}

final class ErrorHandler: ErrorHandlerProtocol {
    func handle(_ error: AppError) {
        logError(error)
        
        // Show user-friendly error message
        DispatchQueue.main.async {
            self.showErrorAlert(error)
        }
    }
    
    func showErrorAlert(_ error: AppError) {
        // Implementation for showing alerts
    }
    
    func logError(_ error: AppError) {
        // Log to analytics/crash reporting
        print("Error: \(error.localizedDescription)")
    }
}
```

---

## –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å

### Security Measures
```swift
// Biometric Authentication
import LocalAuthentication

final class BiometricService {
    func authenticateUser() async -> Bool {
        let context = LAContext()
        var error: NSError?
        
        guard context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) else {
            return false
        }
        
        do {
            let result = try await context.evaluatePolicy(
                .deviceOwnerAuthenticationWithBiometrics,
                localizedReason: "–î–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—é —Ç—Ä–µ–±—É–µ—Ç—Å—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è"
            )
            return result
        } catch {
            return false
        }
    }
}

// Data Encryption
import CryptoKit

final class EncryptionService {
    private let key = SymmetricKey(size: .bits256)
    
    func encrypt(_ data: Data) throws -> Data {
        let sealedBox = try AES.GCM.seal(data, using: key)
        return sealedBox.combined!
    }
    
    func decrypt(_ encryptedData: Data) throws -> Data {
        let sealedBox = try AES.GCM.SealedBox(combined: encryptedData)
        return try AES.GCM.open(sealedBox, using: key)
    }
}
```

### Performance Optimization
```swift
// Memory Management
final class ImageCache {
    private let cache = NSCache<NSString, UIImage>()
    private let fileManager = FileManager.default
    
    init() {
        cache.countLimit = 100
        cache.totalCostLimit = 50 * 1024 * 1024 // 50MB
    }
    
    func image(for key: String) -> UIImage? {
        return cache.object(forKey: key as NSString)
    }
    
    func setImage(_ image: UIImage, for key: String) {
        cache.setObject(image, forKey: key as NSString)
    }
}

// Background Processing
actor BackgroundProcessor {
    func processHeavyTask<T>(_ operation: @escaping () async throws -> T) async throws -> T {
        return try await withTaskGroup(of: T.self) { group in
            group.addTask {
                try await operation()
            }
            
            return try await group.next()!
        }
    }
}

// Lazy Loading –¥–ª—è –±–æ–ª—å—à–∏—Ö —Å–ø–∏—Å–∫–æ–≤
struct LazyHabitsList: View {
    @State private var habits: [Habit] = []
    @State private var isLoading = false
    
    var body: some View {
        LazyVStack {
            ForEach(habits) { habit in
                HabitRowView(habit: habit)
                    .onAppear {
                        if habit == habits.last {
                            loadMoreHabits()
                        }
                    }
            }
            
            if isLoading {
                ProgressView()
            }
        }
    }
    
    private func loadMoreHabits() {
        guard !isLoading else { return }
        // Load more implementation
    }
}
```

---

## –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### Test Architecture
```swift
// Test Base Classes
class BaseTestCase: XCTestCase {
    var services: MockServiceContainer!
    var modelContext: ModelContext!
    
    override func setUp() {
        super.setUp()
        
        // Setup in-memory Core Data stack
        let configuration = ModelConfiguration(isStoredInMemoryOnly: true)
        let container = try! ModelContainer(for: testSchema, configurations: [configuration])
        modelContext = container.mainContext
        
        // Setup mock services
        services = MockServiceContainer(modelContext: modelContext)
    }
}

// Mock Services
final class MockHabitRepository: HabitRepositoryProtocol {
    var habits: [Habit] = []
    
    func fetchActiveHabits() async throws -> [Habit] {
        return habits.filter { $0.isActive }
    }
    
    func save(_ habit: Habit) async throws {
        if let index = habits.firstIndex(where: { $0.id == habit.id }) {
            habits[index] = habit
        } else {
            habits.append(habit)
        }
    }
}

// Test Example
final class HabitsListViewModelTests: BaseTestCase {
    private var viewModel: HabitsListViewModel!
    
    override func setUp() {
        super.setUp()
        viewModel = HabitsListViewModel(
            habitRepository: services.habitRepository,
            gameService: services.gameService
        )
    }
    
    func testLoadHabits() async throws {
        // Given
        let testHabits = [
            Habit(name: "Test Habit 1"),
            Habit(name: "Test Habit 2")
        ]
        services.habitRepository.habits = testHabits
        
        // When
        viewModel.send(.loadHabits)
        
        // Wait for async operation
        try await Task.sleep(nanoseconds: 100_000_000)
        
        // Then
        XCTAssertEqual(viewModel.state.habits.count, 2)
        XCTAssertFalse(viewModel.state.isLoading)
        XCTAssertNil(viewModel.state.error)
    }
}
```

---

–≠—Ç–∞ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç:

‚úÖ **–ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å** - –º–æ–¥—É–ª—å–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–æ–∑–≤–æ–ª—è–µ—Ç –ª–µ–≥–∫–æ –¥–æ–±–∞–≤–ª—è—Ç—å –Ω–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
‚úÖ **–¢–µ—Å—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å** - —á–µ—Ç–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏ –∏ dependency injection
‚úÖ **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å** - –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥–∞–Ω–Ω—ã–º–∏
‚úÖ **–°–æ–≤—Ä–µ–º–µ–Ω–Ω–æ—Å—Ç—å** - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–π iOS
‚úÖ **–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å** - –∑–∞—â–∏—Ç–∞ –¥–∞–Ω–Ω—ã—Ö –∏ –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
‚úÖ **–ê–Ω–∞–ª–∏—Ç–∏–∫–∞** - –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è —Å–∏—Å—Ç–µ–º–∞ –∞–Ω–∞–ª–∏–∑–∞ –∏ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–π          üÜï
‚úÖ **–£–º–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏** - AI-powered —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –∏ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è        üÜï
‚úÖ **HealthKit –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è** - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Å–±–æ—Ä –∏ –∞–Ω–∞–ª–∏–∑ –¥–∞–Ω–Ω—ã—Ö    üÜï

## üöÄ –ù–æ–≤—ã–µ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ (v2.0)

### –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã:
- **AdvancedHealthKitService** - –ø–æ–ª–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å HealthKit (10 –º–µ—Ç—Ä–∏–∫)
- **HabitAnalyticsService** - —Å—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ –∏ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏
- **SmartFeaturesService** - —É–º–Ω—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
- **HabitAnalyticsViewModel** - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏
- **HealthIntegrationViewModel** - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ HealthKit –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π
- **TrendsViewModel** - –∞–Ω–∞–ª–∏–∑ —Ç—Ä–µ–Ω–¥–æ–≤ –∏ –ø—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞–Ω–∏–µ
- **InsightsViewModel** - –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ –∏–Ω—Å–∞–π—Ç—ã –∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
- **HabitHeatmapView** - –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –∫–∞–ª–µ–Ω–¥–∞—Ä—å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
- **AnalyticsTabView** - –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã–π —ç–∫—Ä–∞–Ω –∞–Ω–∞–ª–∏—Ç–∏–∫–∏
- **AdvancedChartComponents** - –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –≥—Ä–∞—Ñ–∏–∫–∏ –∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏

### –ö–ª—é—á–µ–≤—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã:
- **–ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è –ü–∏—Ä—Å–æ–Ω–∞** –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Å–≤—è–∑–µ–π –º–µ–∂–¥—É –ø—Ä–∏–≤—ã—á–∫–∞–º–∏ –∏ –∑–¥–æ—Ä–æ–≤—å–µ–º
- **–õ–∏–Ω–µ–π–Ω–∞—è —Ä–µ–≥—Ä–µ—Å—Å–∏—è** –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç—Ä–µ–Ω–¥–æ–≤
- **–°—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑** –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ —É—Å–ø–µ—à–Ω–æ—Å—Ç–∏
- **–ü—Ä–µ–¥—Å–∫–∞–∑–∞—Ç–µ–ª—å–Ω—ã–µ –º–æ–¥–µ–ª–∏** –¥–ª—è –æ—Ü–µ–Ω–∫–∏ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ —É—Å–ø–µ—Ö–∞
- **–ê–ª–≥–æ—Ä–∏—Ç–º—ã —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π** –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö

### –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:
- –ê–Ω–∞–ª–∏–∑ —Ç—Ä–µ–Ω–¥–æ–≤: < 100ms –¥–ª—è 1 –ø—Ä–∏–≤—ã—á–∫–∏
- Heatmap –¥–ª—è –≥–æ–¥–∞: < 200ms
- –ö–æ—Ä—Ä–µ–ª—è—Ü–∏–æ–Ω–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞: < 500ms –¥–ª—è 10 –ø—Ä–∏–≤—ã—á–µ–∫
- ML –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è: < 50ms

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —ç—Ç–æ—Ç –¥–æ–∫—É–º–µ–Ω—Ç –∫–∞–∫ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø—Ä–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–∞–∂–¥–æ–≥–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è. 